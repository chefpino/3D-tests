<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../../css/main.css" />
    <script src="../../navigation/menu.js"></script>
    <script src="../../pages-data/3d.parametrical.data.js"></script>
    <script src="../../math-library/math-complexnumbers.js"></script>
    <script src="../../math-library/math.quaternions.js"></script>
    <script src="../../navigation/controls.js"></script>
    <script src="../../math-library/remap.js"></script>
    <script src="../2d/2d-library.js"></script>
  </head>

  <body onload="init();">
    <table style="border: 1px solid; padding: 0px;" width="100%" height="100%">
        <tr>
          <td valign="top" >
                <div id="menu"></div>
          </td>
          <td rowspan=2 valign="top" align=left><canvas
            id="myCanvas"
            width="1000"
            height="500"
            style="border: 0px solid; padding: 0px;"></canvas>
        </td>
        </tr>
        <tr>
        <td valign="top" width="100">
          <div id="content"></div>
          <img height=1 width=420 src="../../imgs/1pxBlack.gif">
          <div id="listFunctions">placeholder</div>
          <img height=1 width=420 src="../../imgs/1pxBlack.gif">
        <div id="dynamicSliders"></div>
        </td>
      </tr>
    </table>
    <script>

      "use strict";
      //-----------------------------
      const canvas = document.getElementById("myCanvas");
      const cW = 1000; //canvas.clientWidth;
      const cH = 700; //canvas.clientHeight;
      const ctx = canvas.getContext("2d");
      const xAxis=qt(0,1,0,0);
      const yAxis=qt(0,0,1,0);
      const zAxis=qt(0,0,0,1);

      canvas.width = cW;
      canvas.height = cH;
      const fixedOrigin = true; //can be a parameter also
      const π = Math.PI;

      //--- declare global variables
      var x0, x1, y0, y1;
      var z0, z1;
      var gridRes;
      var funcRes;
      var funcOpacity;
      var scaleFactor;
      var xyAngle, zyAngle, zxAngle;
      var zFact;      
      var perspective;
      var diagonal; //maxim distance between 2 points on the pavement

      loadValues();      

      var reMap = new ReMap(cW, cH, x0, x1, y0, y1, fixedOrigin);
      reMap.objCanvas = ctx;
      reMap.lockRatio=true;

      


//-------------------------------------------
      function init() {
        genNavigation("threeD", true);
        generateControls();
        displayFunctions();
        //fileToParameters(); //initiate event listener for file uploader
        loadvaluesandgo();        
      }
//-------------------------------------------
      function loadValues(){
       x0 = params.x0.val;
       x1 = params.x1.val;
       y0 = params.y0.val;
       y1 = params.y1.val;
       z0 = params.y0.val;
       z1 = params.y1.val;
       gridRes=params.gridRes.val;
       funcRes=params.funcRes.val;
       funcOpacity=params.funcOpacity.val;
       scaleFactor=params.scaleFactor.val;
       xyAngle=params.xyAngle.val;
       zyAngle=params.zyAngle.val;
       zxAngle=params.zxAngle.val;
       zFact=params.zFact.val;
       perspective=params.perspective.val;
       diagonal=Math.sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
      }


//-------------------------------------------
      function loadvaluesandgo() {
        //go! button

        // -- load parameters from params object
        loadValues();

        reMap.scaleFactor=scaleFactor;

        //to change and improve
        z0 = params.y0.val;
        z1 = params.y1.val;

        //---clear canvas
        ctx.clearRect(0, 0, cW, cH);

        //--- draw base domain
        drawPavement(gridRes);

        //---plot function
        plotAll();
      }

//-------------------------------------------
      function drawPavement(res) {

        reMap.lineWidth = 0.5;
       //height = avrg(x1,y1), can be improved
       var z1 = (x1+y1)/2;

        //full horizontal pavement
          //lines parallel to y axe
          for (var x = x0; x <= x1; x = x + (x1-x0) / res) {
            var t1 = ct(x, y0, 0);
            var t2 = ct(x, y1, 0);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "grey");
          }
          //lines parallel to x axe
          for (var y = y0; y <= y1; y = y + (y1-y0) / res) {
            var t1 = ct(x0, y, 0);
            var t2 = ct(x1, y, 0);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "grey");
          }
       
       //vertical pavement, passing by origin (can be improved by passing per mid of range?)   

       //--- vertical lines along x axe
       for (var x = 0; x <= x1; x = x + 2 * (x1) / res) {
            var t1 = ct(x, 0, 0);
            var t2 = ct(x, 0, z1);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }
       // --- vertical lines along y axe   
       for (var y = 0; y <= y1; y = y + 2* (y1) / res) {
            var t1 = ct(0, y, 0);
            var t2 = ct(0, y, z1);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }
      // -- horizontal lines parallel to x axis    
      for (var z = 0; z <= z1; z = z + 2* (z1) / res) {
            var t1 = ct(0, 0, z);
            var t2 = ct(0, y1, z);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }
      // -- horizontal lines parallel to y axis    
      for (var z = 0; z <= z1; z = z + 2* (z1) / res) {
            var t1 = ct(0, 0, z);
            var t2 = ct(x1, 0, z);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }

      
        //axes in blue, longer than range
        var t1 = ct(x0 * (1 + 2/res), 0, 0);
        var t2 = ct(x1 * (1 + 2/res), 0, 0);
        reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "blue");
        var t1 = ct(0, y0 * (1 + 2/res), 0);
        var t2 = ct(0, y1 * (1 + 2/res), 0);
        reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "blue");
        var t1 = ct(0, 0, -z1 * (1 + 2/res));
        var t2 = ct(0, 0, z1 * (1+2/res));
        reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "blue");


        arrowHead(x1 * (1 + 2/res),0,0,1/2*(x1-x0)/gridRes); //x
        arrowHead(0,y1 * (1 + 2/res),0,1/2*(y1-y0)/gridRes); //y 
        arrowHead(0,0,z1 * (1 + 2/res),1/2*(x1-x0)/gridRes); //y 

      }
//---------------------------------
function temp(t){

  return {
      x: Math.cos(3*t)*(3+Math.cos(4*t)),
      y: Math.sin(3*t)*(3+Math.cos(4*t)),
      z: Math.sin(4*t)
  }

}
/*
x: Math.cos(3*t)*(3+Math.cos(4*t)),
      y: Math.sin(3*t)*(3+Math.cos(4*t)),
      z: Math.sin(4*t)
*/
//-------------------------------------------
      function plotColoredFunction(objF, res) {

        var t0=0; var t1=Math.PI*2 // params
        var t=t0;
        var dt=(t1-t0)/res; //param
        var x = temp(t).x;
        var y = temp(t).y;
        var z = temp(t).z;

        console.table(temp(t));
        

        var pt1 = ct(x, y, z);
        var pt2;

        var i = 0;

        reMap.lineWidth = .5;
        //ctx.globalAlpha = funcOpacity; //opacity

        for (i = 1; i <= res; i++) {
          t = t0 + i * dt;
          pt2=ct(temp(t).x,temp(t).y,temp(t).z);
          
                
          ctx.beginPath();
          ctx.moveTo(reMap.x(pt1.x), reMap.y(pt1.y));
          ctx.lineTo(reMap.x(pt2.x), reMap.y(pt2.y));
          ctx.stroke();
          pt1=pt2

          }
        }


      //------------------------------------------

      // --- ct maps a 3d point to a 2d map representing the 3d space
      function ct(x, y, z) {
        
        let pt1=qt(0,x,y,z); //point in 3d as a quaternion    
        
        pt1=qRot(zAxis,xyAngle,pt1); //point rotated around z axis
        pt1=qRot(yAxis,zxAngle,pt1); //point rotated around x axis
        pt1=qRot(xAxis,zyAngle,pt1); //point rotated around y axis

        //for perspective it's better to traslate the rotated point away from the canvas
        //diagonal is the size of the pavement diagonal
        let perspectiveFactor=1;
        if (perspective){perspectiveFactor=pt1.c+ diagonal;} //works, a bit far

        return {
          x: pt1.b/perspectiveFactor,
          y: pt1.d/perspectiveFactor
        }
      }
//-------------------------------------------
      function arrowHead(x,y,z,arrLength){
         //k is the complex number representing the tip of the arrow on the x,y plane
         //k1 is 45° and of module proportional to the x0,x1,res
         reMap.lineWidth=1;
         if (z==0){
          var k=c(x,y);
          var k1=p(k,c(-1,1/2)); //angle of arrow sides
          k1=r(arrLength,m(k1).theta); //new vector, same angle, reduced magnitude
          k1=s(k,k1); // tip of one side of arrow
          var t1=ct(k.x,k.y,0);
          var t2=ct(k1.x,k1.y,0);
          reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");

          k1=p(k,c(-1,-1/2)); //opposite angle of arrow side
          k1=r(arrLength,m(k1).theta); //new vector, same angle, reduced magnitude
          k1=s(k,k1); // tip of one side of arrow
          var t2=ct(k1.x,k1.y,0);
          reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");
        }
        else //z > 0, temporary arrow, improve with quaternions
        {
           t1=ct(x,y,z);
           t2=ct(x+arrLength/2,y,z-arrLength);
           reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");
           t2=ct(x-arrLength/2,y,z-arrLength);
           reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");
        }       

      }
//-------------------------------------------
function displayFunctions(){
  document.getElementById("listFunctions").innerHTML=listFunctions();
}
//-------------------------------------------
function plotAll(){

for (const key in params.functions) {
    const element = params.functions[key];
    if (element != false){
    function g(x,y) {  
       return eval(element);  
    };  
    plotColoredFunction(g,funcRes);
  }
}
}
    </script> 
  </body>
</html>
