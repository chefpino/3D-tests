<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../../css/main.css" />
    <script src="../../navigation/menu.js"></script>
    <script src="../data/3d-color.data.js"></script>
    <script src="../../math-library/math-complexnumbers.js"></script>
    <script src="../../fractals/fractals-library/controls.js"></script>
    <script src="../../math-library/graphicfunctions.js"></script>
  </head>

  <body onload="init();">
    <table border="0">
      <tr>
        <td valign="top">
          <div id="menu"></div>
          <hr /> 
          <div id="content"></div>
          <hr />
          <div id="dynamicSliders"></div>
        </td>
        <td valign=top>
          <canvas
            id="myCanvas"
            width="1000"
            height="600"
            style="border: 1px solid;"
          ></canvas>
        </td>
      </tr>
    </table>
    <script>

      "use strict";
      //-----------------------------
      const canvas = document.getElementById("myCanvas");
      const cW = 1000; //canvas.clientWidth;
      const cH = 600; //canvas.clientHeight;
      const ctx = canvas.getContext("2d");
      canvas.width = cW;
      canvas.height = cH;

      //--- declare global variables
      var x0 = params.x0.val;
      var x1 = params.x1.val;
      var y0 = params.y0.val;
      var y1 = params.y1.val;
      var z0 = params.y0.val;
      var z1 = params.y1.val;
      var gridRes=params.gridRes.val;
      var funcRes=params.funcRes.val;
      var funcOpacity=params.funcOpacity.val;
      var scaleFactor=params.scaleFactor.val;
      var rotationAngle=params.rotationAngle.val;
      
      const fixedOrigin = true; //can be a parameter also
      const π = Math.PI;

      var reMap = new ReMap(cW, cH, x0, x1, y0, y1, fixedOrigin);
      reMap.objCanvas = ctx;

      //parameters that decide the new base vectors
      var c1 = new r(1, rotationAngle);
      c2 = new r(1, π/2);
      var c2 = p(c1, c2);
      const o = c(0, 0); //origin

      //------------------------------------------------------------------
      function init() {
        genNavigation("threeD", false);
        generateControls();
        fileToParameters(); //initiate event listener for file uploader
        loadvaluesandgo();
      }
      //-----------------------------------------------------------------------
      function loadvaluesandgo() {
        //go! button

        // -- load parameters from params object
        x0 = params.x0.val;
        x1 = params.x1.val;
        y0 = params.y0.val;
        y1 = params.y1.val;

        gridRes=params.gridRes.val;
        funcRes=params.funcRes.val;
        funcOpacity=params.funcOpacity.val;
        scaleFactor=params.scaleFactor.val;
        rotationAngle=params.rotationAngle.val;

        c1 = new r(1, rotationAngle);
        // c2 = new r(1, π + π / 3);
        c2 = new r(1, π/2);
        c2 = p(c1, c2);


        reMap.scaleFactor=scaleFactor;

        //to change and improve
        z0 = params.y0.val;
        z1 = params.y1.val;

        //---clear canvas
        ctx.clearRect(0, 0, cW, cH);

        //--- draw base domain
        drawPavement(gridRes);

        //---plot function
        plotColoredFunction(funcRes);
      }

      //-------------------------------------------------
      function drawPavement(res) {

        reMap.lineWidth = 1;
       //height = avrg(x1,y1), can be improved
       var z1 = (x1+y1)/2;

        //full horizontal pavement
          //lines parallel to y axe
          for (var x = x0; x <= x1; x = x + (x1-x0) / res) {
            var t1 = ct(x, y0, 0);
            var t2 = ct(x, y1, 0);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "lightgrey");
          }
          //lines parallel to x axe
          for (var y = y0; y <= y1; y = y + (y1-y0) / res) {
            var t1 = ct(x0, y, 0);
            var t2 = ct(x1, y, 0);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "lightgrey");
          }
       
       //vertical pavement, passing by origin (can be improved by passing per mid of range?)   

       //--- vertical lines along x axe
       for (var x = 0; x <= x1; x = x + 2 * (x1) / res) {
            var t1 = ct(x, 0, 0);
            var t2 = ct(x, 0, z1);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }
       // --- vertical lines along y axe   
       for (var y = 0; y <= y1; y = y + 2* (y1) / res) {
            var t1 = ct(0, y, 0);
            var t2 = ct(0, y, z1);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }
      // -- horizontal lines parallel to x axis    
      for (var z = 0; z <= z1; z = z + 2* (z1) / res) {
            var t1 = ct(0, 0, z);
            var t2 = ct(0, y1, z);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }
      // -- horizontal lines parallel to y axis    
      for (var z = 0; z <= z1; z = z + 2* (z1) / res) {
            var t1 = ct(0, 0, z);
            var t2 = ct(x1, 0, z);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }

      
        //axes in blue, longer than range
        var t1 = ct(x0 * (1 + 2/res), 0, 0);
        var t2 = ct(x1 * (1 + 2/res), 0, 0);
        reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "blue");
        var t1 = ct(0, y0 * (1 + 2/res), 0);
        var t2 = ct(0, y1 * (1 + 2/res), 0);
        reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "blue");
        var t1 = ct(0, 0, -z1 * (1 + 2/res));
        var t2 = ct(0, 0, z1 * (1+2/res));
        reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "blue");


        arrowHead(x1 * (1 + 2/res),0,0,1/2*(x1-x0)/gridRes); //x
        arrowHead(0,y1 * (1 + 2/res),0,1/2*(y1-y0)/gridRes); //y 
        arrowHead(0,0,z1 * (1 + 2/res),1/2*(x1-x0)/gridRes); //y 

      }
      //-----------------------------------------------

      function plotColoredFunction(res) {


        var dx = (x1 - x0) / res;
        var dy = (y1 - y0) / res;

        var x = x0;
        var y = y0;
        var i = 0;
        var j = 0;

        var pt, t1, t2;
        var iTemp;

        reMap.lineWidth = 0.5;
        ctx.globalAlpha = funcOpacity; //opacity

        for (i = 0; i <= res; i++) {
          x = x0 + i * dx;

          for (j = 0; j <= res; j++) {
            y = y0 + j * dy;

            pt = ct(x, y, g(x, y)); // point transformed in new coord system
            ctx.beginPath();
            ctx.moveTo(reMap.x(pt.x), reMap.y(pt.y));
            pt = ct(x + dx, y, g(x + dx, y));
            ctx.lineTo(reMap.x(pt.x), reMap.y(pt.y));
            pt = ct(x + dx, y + dy, g(x + dx, y + dy));
            ctx.lineTo(reMap.x(pt.x), reMap.y(pt.y));
            pt = ct(x, y + dy, g(x, y + dy));
            ctx.lineTo(reMap.x(pt.x), reMap.y(pt.y));
            ctx.closePath();
            iTemp = Math.round(256 * g(x, y));
            ctx.stroke();
            ctx.fillStyle = "rgb(200, " + iTemp + ", 100)";
            ctx.fill();


            t1 = ct(x, y, g(x, y)); //baseChange(c(x,y0),c1,c2);
            t2 = ct(x + dx, y, g(x + dx, y));
            reMap.drawSegment(c(t1.x, t1.y), c(t2.x, t2.y), "blue");
            t2 = ct(x, y + dy, g(x, y + dy));
            reMap.drawSegment(c(t1.x, t1.y), c(t2.x, t2.y), "blue");
          }
        }

        ctx.globalAlpha = 1; //opacity

        //write x0,x1 etc --- can be done separately and
        //the number should be on the correct side, following the vector direction
        var tempP;
        ctx.fillStyle = "red";
        tempP=ct(x0,y0,0);
        ctx.fillText("x0", reMap.x(tempP.x), reMap.y(tempP.y));
        tempP=ct(x1,y0,0);
        ctx.fillText("x1", reMap.x(tempP.x), reMap.y(tempP.y));
        tempP=ct(x0,y1,0);
        ctx.fillText("y1", reMap.x(tempP.x), reMap.y(tempP.y));
        //console.table(tempP);





      }




      //------------------------------------------
      function baseChange(z) {
        //works because initial base is 1,0 and 0,1 (1 and i)
        return s(p(z.x, c1), p(z.y, c2));
      }
      // --- ct maps a 3d point to a 2d map representing the 3d space
      function ct(x, y, z) {
        var tempC = baseChange(c(x, y));
        return {
          x: tempC.x,
          y: tempC.y + z,
        };
      }

      //---------------------------------------------------------------
      function g(x, y) {
        return x*x+y*y;
        //return 2-2*Math.sin(.02*(x*x+y*y)); //--sgabello
        //return Math.sqrt(x*x+y*y);         //--cono
        //return 5-Math.abs(x+y)-Math.abs(x-y);
        //return Math.sin(0.5 * x + y) * Math.cos(0.5 * y - x); //bello,0,10,0,10,-12,12
        // return x*(.5*x-2*y);
        //return 50/(x*x+y*y);
        //return x*x-.3*y*y;
        //return 0;
      }

      //--------------
      function arrowHead(x,y,z,arrLength){
         //k is the complex number representing the tip of the arrow on the x,y plane
         //k1 is 45° and of module proportional to the x0,x1,res
         reMap.lineWidth=1;
         if (z==0){
          var k=c(x,y);
          var k1=p(k,c(-1,1/2)); //angle of arrow sides
          k1=r(arrLength,m(k1).theta); //new vector, same angle, reduced magnitude
          k1=s(k,k1); // tip of one side of arrow
          var t1=ct(k.x,k.y,0);
          var t2=ct(k1.x,k1.y,0);
          reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");

          k1=p(k,c(-1,-1/2)); //opposite angle of arrow side
          k1=r(arrLength,m(k1).theta); //new vector, same angle, reduced magnitude
          k1=s(k,k1); // tip of one side of arrow
          var t2=ct(k1.x,k1.y,0);
          reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");
        }
        else //z > 0, temporary arrow, improve with quaternions
        {
           t1=ct(x,y,z);
           t2=ct(x+arrLength/2,y,z-arrLength);
           reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");
           t2=ct(x-arrLength/2,y,z-arrLength);
           reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");
        }

         

      }


    </script> 
  </body>
</html>
