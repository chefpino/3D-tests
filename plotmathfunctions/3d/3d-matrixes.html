<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="../../css/main.css" />
    <script src="../../navigation/menu.js"></script>
    <script src="../../pages-data/3d-color.data.js"></script>
    <script src="../../math-library/math-complexnumbers.js"></script>
    <script src="../../math-library/math.quaternions.js"></script>
    <script src="../../math-library/math.matrixes.js"></script>
    <script src="../../navigation/controls.js"></script>
    <script src="../../math-library/remap.js"></script>
    <script src="../2d/2d-library.js"></script>
  </head>

  <body onload="init();">
    <table style="border: 1px solid; padding: 0px;" width="100%" height="100%">
        <tr>
          <td valign="top" >
                <div id="menu"></div>
          </td>
          <td rowspan=2 valign="top" align=left><canvas
            id="myCanvas"
            width="1000"
            height="500"
            style="border: 0px solid; padding: 0px;"></canvas>
        </td>
        </tr>
        <tr>
        <td valign="top" width="100">
          <div id="content"></div>
          <img height=1 width=400 src="../../imgs/1pxBlack.gif">
          <div id="listFunctions">placeholder</div>
          <img height=1 width=400 src="../../imgs/1pxBlack.gif">
        <div id="dynamicSliders"></div>
        </td>
      </tr>
    </table>
    <script>

      "use strict";
      //-----------------------------
      const canvas = document.getElementById("myCanvas");
      const cW = 1000; //canvas.clientWidth;
      const cH = 700; //canvas.clientHeight;
      const ctx = canvas.getContext("2d");
      canvas.width = cW;
      canvas.height = cH;
      const fixedOrigin = true; //can be a parameter also
      const π = Math.PI;

      //--- declare global variables
      var x0, x1, y0, y1;
      var z0, z1;
      var gridRes;
      var funcRes;
      var funcOpacity;
      var scaleFactor;
      var xyAngle, zyAngle, zxAngle;
      var zFact;      
      let Rx=new matrix(3,3);
      let Ry=new matrix(3,3);
      let Rz=new matrix(3,3);   

      loadValues();      


      var reMap = new ReMap(cW, cH, x0, x1, y0, y1, fixedOrigin);
      reMap.objCanvas = ctx;
      reMap.lockRatio=true;


//-------------------------------------------
      function init() {
        genNavigation("threeDmatrixes", true);
        generateControls();
        displayFunctions();
        //fileToParameters(); //initiate event listener for file uploader
        loadvaluesandgo();        
      }
//-------------------------------------------
      function loadValues(){
       x0 = params.x0.val;
       x1 = params.x1.val;
       y0 = params.y0.val;
       y1 = params.y1.val;
       z0 = params.y0.val;
       z1 = params.y1.val;
       gridRes=params.gridRes.val;
       funcRes=params.funcRes.val;
       funcOpacity=params.funcOpacity.val;
       scaleFactor=params.scaleFactor.val;
       xyAngle=params.xyAngle.val;
       zyAngle=params.zyAngle.val;
       zxAngle=params.zxAngle.val;
       zFact=params.zFact.val;

            Rx[1][1]=1;
                      Rx[2][2]=Math.cos(zyAngle); Rx[2][3]=-Math.sin(zyAngle);
                      Rx[3][2]=Math.sin(zyAngle); Rx[3][3]= Math.cos(zyAngle);
                      
            Ry[1][1]=Math.cos(zxAngle);           Ry[1][3] = Math.sin(zxAngle);
                                       Ry[2][2]=1;
            Ry[3][1]=-Math.sin(zxAngle);          Ry[3][3] = Math.cos(zxAngle);

            Rz[1][1]=Math.cos(xyAngle); Rz[1][2]= -Math.sin(xyAngle);
            Rz[2][1]=Math.sin(xyAngle); Rz[2][2]=  Math.cos(xyAngle);
                                                                     Rz[3][3]=1;


      }


//-------------------------------------------
      function loadvaluesandgo() {
        //go! button

        // -- load parameters from params object
        loadValues();

        reMap.scaleFactor=scaleFactor;

        //to change and improve
        z0 = params.y0.val;
        z1 = params.y1.val;

        //---clear canvas
        ctx.clearRect(0, 0, cW, cH);

        //--- draw base domain
        drawPavement(gridRes);

        //---plot function
        plotAll();
      }

//-------------------------------------------
      function drawPavement(res) {

        reMap.lineWidth = 0.5;
       //height = avrg(x1,y1), can be improved
       var z1 = (x1+y1)/2;

        //full horizontal pavement
          //lines parallel to y axe
          for (var x = x0; x <= x1; x = x + (x1-x0) / res) {
            var t1 = ct(x, y0, 0);
            var t2 = ct(x, y1, 0);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "grey");
          }
          //lines parallel to x axe
          for (var y = y0; y <= y1; y = y + (y1-y0) / res) {
            var t1 = ct(x0, y, 0);
            var t2 = ct(x1, y, 0);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "grey");
          }
       
       //vertical pavement, passing by origin (can be improved by passing per mid of range?)   

       //--- vertical lines along x axe
       for (var x = 0; x <= x1; x = x + 2 * (x1) / res) {
            var t1 = ct(x, 0, 0);
            var t2 = ct(x, 0, z1);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }
       // --- vertical lines along y axe   
       for (var y = 0; y <= y1; y = y + 2* (y1) / res) {
            var t1 = ct(0, y, 0);
            var t2 = ct(0, y, z1);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }
      // -- horizontal lines parallel to x axis    
      for (var z = 0; z <= z1; z = z + 2* (z1) / res) {
            var t1 = ct(0, 0, z);
            var t2 = ct(0, y1, z);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }
      // -- horizontal lines parallel to y axis    
      for (var z = 0; z <= z1; z = z + 2* (z1) / res) {
            var t1 = ct(0, 0, z);
            var t2 = ct(x1, 0, z);
            reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "red");
          }

      
        //axes in blue, longer than range
        var t1 = ct(x0 * (1 + 2/res), 0, 0);
        var t2 = ct(x1 * (1 + 2/res), 0, 0);
        reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "blue");
        var t1 = ct(0, y0 * (1 + 2/res), 0);
        var t2 = ct(0, y1 * (1 + 2/res), 0);
        reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "blue");
        var t1 = ct(0, 0, -z1 * (1 + 2/res));
        var t2 = ct(0, 0, z1 * (1+2/res));
        reMap.drawSegment(c(t1.x,t1.y), c(t2.x, t2.y), "blue");


        arrowHead(x1 * (1 + 2/res),0,0,1/2*(x1-x0)/gridRes); //x
        arrowHead(0,y1 * (1 + 2/res),0,1/2*(y1-y0)/gridRes); //y 
        arrowHead(0,0,z1 * (1 + 2/res),1/2*(x1-x0)/gridRes); //y 

      }
//-------------------------------------------
      function plotColoredFunction(objF, res) {

        var dx = (x1 - x0) / res;
        var dy = (y1 - y0) / res;

        var x = x0;
        var y = y0;
        var i = 0;
        var j = 0;

        var pt, t1, t2;
        var iTemp;

        reMap.lineWidth = 0.5;
        ctx.globalAlpha = funcOpacity; //opacity

        for (i = 0; i <= res; i++) {
          x = x0 + i * dx;

          for (j = 0; j <= res; j++) {
            y = y0 + j * dy;

            pt = ct(x, y, objF(x, y)); // point transformed in new coord system
            ctx.beginPath();
            ctx.moveTo(reMap.x(pt.x), reMap.y(pt.y));
            pt = ct(x + dx, y, objF(x + dx, y));
            ctx.lineTo(reMap.x(pt.x), reMap.y(pt.y));
            pt = ct(x + dx, y + dy, objF(x + dx, y + dy));
            ctx.lineTo(reMap.x(pt.x), reMap.y(pt.y));
            pt = ct(x, y + dy, objF(x, y + dy));
            ctx.lineTo(reMap.x(pt.x), reMap.y(pt.y));
            ctx.closePath();
            iTemp = Math.round(256 * objF(x, y));
            ctx.stroke();
            ctx.fillStyle = "rgb(200, " + iTemp + ", 100)";
            ctx.fill();


            t1 = ct(x, y, objF(x, y)); //baseChange(c(x,y0),c1,c2);
            t2 = ct(x + dx, y, objF(x + dx, y));
            reMap.drawSegment(c(t1.x, t1.y), c(t2.x, t2.y), "blue");
            t2 = ct(x, y + dy, objF(x, y + dy));
            reMap.drawSegment(c(t1.x, t1.y), c(t2.x, t2.y), "blue");
          }
        }

        ctx.globalAlpha = 1; //opacity

        //write x0,x1 etc --- can be done separately and
        //the number should be on the correct side, following the vector direction
        var tempP;
        ctx.fillStyle = "red";
        tempP=ct(x0,y0,0);
        ctx.fillText("x0, y0", reMap.x(tempP.x), reMap.y(tempP.y));
        tempP=ct(x1,y0,0);
        ctx.fillText("x1, y0", reMap.x(tempP.x), reMap.y(tempP.y));
        tempP=ct(x0,y1,0);
        ctx.fillText("x0,y1", reMap.x(tempP.x), reMap.y(tempP.y));
        tempP=ct(x1,y1,0);
        ctx.fillText("x1,y1", reMap.x(tempP.x), reMap.y(tempP.y));
        tempP=ct(0,0,0);
        ctx.fillText("o", reMap.x(tempP.x), reMap.y(tempP.y));

      }
      //------------------------------------------

      // --- ct maps a 3d point to a 2d map representing the 3d space
      function ct(x, y, z) {
     
        var rotatedVector=new matrix(3,1);
        rotatedVector[1][1]=x;
        rotatedVector[2][1]=y;
        rotatedVector[3][1]=z;

        //apply rotations
        rotatedVector=multiplyMatrix(Rz,rotatedVector);
        rotatedVector=multiplyMatrix(Rx,rotatedVector);
        rotatedVector=multiplyMatrix(Ry,rotatedVector);

        return {
          x: rotatedVector[1][1],
          y: rotatedVector[3][1]
        }
      }
//-------------------------------------------
      function arrowHead(x,y,z,arrLength){
         //k is the complex number representing the tip of the arrow on the x,y plane
         //k1 is 45° and of module proportional to the x0,x1,res
         reMap.lineWidth=1;
         if (z==0){
          var k=c(x,y);
          var k1=p(k,c(-1,1/2)); //angle of arrow sides
          k1=r(arrLength,m(k1).theta); //new vector, same angle, reduced magnitude
          k1=s(k,k1); // tip of one side of arrow
          var t1=ct(k.x,k.y,0);
          var t2=ct(k1.x,k1.y,0);
          reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");

          k1=p(k,c(-1,-1/2)); //opposite angle of arrow side
          k1=r(arrLength,m(k1).theta); //new vector, same angle, reduced magnitude
          k1=s(k,k1); // tip of one side of arrow
          var t2=ct(k1.x,k1.y,0);
          reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");
        }
        else //z > 0, temporary arrow, improve with quaternions
        {
           t1=ct(x,y,z);
           t2=ct(x+arrLength/2,y,z-arrLength);
           reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");
           t2=ct(x-arrLength/2,y,z-arrLength);
           reMap.drawSegment(c(t1.x,t1.y),c(t2.x,t2.y),"black");
        }       

      }
//-------------------------------------------
function displayFunctions(){
  document.getElementById("listFunctions").innerHTML=listFunctions();
}
//-------------------------------------------
function plotAll(){

for (const key in params.functions) {
    const element = params.functions[key];
    if (element != false){
    function g(x,y) {  
       return eval(element);  
    };  
    plotColoredFunction(g,funcRes);
  }
}
}
    </script> 
  </body>
</html>
